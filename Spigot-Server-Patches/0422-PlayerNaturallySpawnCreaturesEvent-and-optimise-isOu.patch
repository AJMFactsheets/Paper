From db1cd248e23597f126b7c6faa1552d84be39afb4 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Fri, 27 Dec 2019 16:56:42 -0800
Subject: [PATCH] PlayerNaturallySpawnCreaturesEvent and optimise
 isOutsideRange

Notes from original patch by Aikar:

This event can be used for when you want to exclude a certain player
from triggering monster spawns on a server.

Also a highly more effecient way to blanket block spawns in a world

For isOutsideRange optimisation (not apart of the patch by aikar),
we optimise the check by using a distance map

diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 6bd962fa3..19a322bfb 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -32,7 +32,7 @@ public abstract class ChunkMapDistance {
     private final Long2ObjectMap<ObjectSet<EntityPlayer>> c = new Long2ObjectOpenHashMap();
     public final Long2ObjectOpenHashMap<ArraySetSorted<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
     private final ChunkMapDistance.a e = new ChunkMapDistance.a();
-    private final ChunkMapDistance.b f = new ChunkMapDistance.b(8);
+    public static final int MOB_SPAWN_RANGE = 8; //private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Paper - no longer used
     //private final ChunkMapDistance.c g = new ChunkMapDistance.c(33); // Paper - no longer used
     private final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.LinkedList<>(); // PAIL pendingChunkUpdates // Paper - use a queue
     private final ChunkTaskQueueSorter i;
@@ -93,7 +93,7 @@ public abstract class ChunkMapDistance {
 
     public boolean a(PlayerChunkMap playerchunkmap) {
         MinecraftServer.softEnsureTickThread("Async map distance update"); // Paper
-        this.f.a();
+        //this.f.a(); // Paper - no longer used
         //this.g.a(); // Paper - no longer used
         int i = Integer.MAX_VALUE - this.e.a(Integer.MAX_VALUE);
         boolean flag = i != 0;
@@ -230,7 +230,7 @@ public abstract class ChunkMapDistance {
         ((ObjectSet) this.c.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
-        this.f.b(i, 0, true);
+        //this.f.b(i, 0, true); // Paper - no longer used
         //this.g.b(i, 0, true); // Paper - no longer used
     }
 
@@ -242,7 +242,7 @@ public abstract class ChunkMapDistance {
         objectset.remove(entityplayer);
         if (objectset.isEmpty()) {
             this.c.remove(i);
-            this.f.b(i, Integer.MAX_VALUE, false);
+            //this.f.b(i, Integer.MAX_VALUE, false); // Paper - no longer used
             //this.g.b(i, Integer.MAX_VALUE, false); // Paper - no longer used
         }
 
@@ -452,13 +452,17 @@ public abstract class ChunkMapDistance {
     // Paper end
 
     public int b() {
-        this.f.a();
-        return this.f.a.size();
+        // Paper start - use distance map to implement
+        // note: this is the spawn chunk count
+        return this.chunkMap.playerChunkTickRangeMap.size();
+        // Paper end
     }
 
     public boolean d(long i) {
-        this.f.a();
-        return this.f.a.containsKey(i);
+        // Paper start - use distance map to implement
+        // note: this is the is spawn chunk method
+        return this.chunkMap.playerChunkTickRangeMap.getObjectsInRange(i) != null;
+        // Paper end
     }
 
     public String c() {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 3bd349496..ed080dd45 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -622,6 +622,37 @@ public class ChunkProviderServer extends IChunkProvider {
         boolean flag1 = this.world.getGameRules().getBoolean(GameRules.DO_MOB_SPAWNING) && !world.getPlayers().isEmpty(); // CraftBukkit
 
         if (!flag) {
+            // Paper start - optimise isOutsideRange
+            boolean spawnMonsters = this.allowMonsters && (this.world.ticksPerMonsterSpawns != 0 && this.world.getTime() % this.world.ticksPerMonsterSpawns == 0);
+            PlayerChunkMap playerChunkMap = this.playerChunkMap;
+            for (EntityPlayer player : this.world.players) {
+                if (!player.affectsSpawning || player.isSpectator()) {
+                    playerChunkMap.playerMobSpawnMap.remove(player);
+                    continue;
+                }
+
+                int viewDistance = player.getEffectiveViewDistance();
+
+                // copied and modified from isOutisdeRange
+                int chunkRange = world.spigotConfig.mobSpawnRange;
+                chunkRange = (chunkRange > viewDistance) ? (byte)viewDistance : chunkRange;
+                chunkRange = (chunkRange > ChunkMapDistance.MOB_SPAWN_RANGE) ? ChunkMapDistance.MOB_SPAWN_RANGE : chunkRange;
+
+                com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(player.getBukkitEntity(), (byte)chunkRange);
+                event.callEvent();
+                if (event.isCancelled() || event.getSpawnRadius() < 0) {
+                    playerChunkMap.playerMobSpawnMap.remove(player);
+                    continue;
+                }
+
+                int range = Math.min(event.getSpawnRadius(), 32); // limit to max view distance
+                int chunkX = com.destroystokyo.paper.util.Util.getChunkCoordinate(player.locX());
+                int chunkZ = com.destroystokyo.paper.util.Util.getChunkCoordinate(player.locZ());
+
+                playerChunkMap.playerMobSpawnMap.update(player, chunkX, chunkZ, range);
+                player.lastEntitySpawnRadiusSquared = (double) ((range << 4) * (range << 4)); // used in isOutsideRange
+            }
+            // Paper end
             this.world.getMethodProfiler().enter("pollingChunks");
             int k = this.world.getGameRules().getInt(GameRules.RANDOM_TICK_SPEED);
             BlockPosition blockposition = this.world.getSpawn();
@@ -675,7 +706,7 @@ public class ChunkProviderServer extends IChunkProvider {
                         // Paper start - timings
                         this.world.timings.chunkRangeCheckSmall.startTiming();
                         // note: this is just a copy of the expression in the if
-                        boolean smallRadiusOutsideRange = flag1 && (this.allowMonsters || this.allowAnimals) && this.world.getWorldBorder().isInBounds(chunk.getPos()) && !this.playerChunkMap.isOutsideOfRange(chunkcoordintpair, true);
+                        boolean smallRadiusOutsideRange = flag1 && (spawnMonsters || this.allowAnimals) && this.world.getWorldBorder().isInBounds(chunk.getPos()) && !this.playerChunkMap.isOutsideOfRange(chunkcoordintpair, true); // Paper - implement configurable spawn interval for monsters
                         this.world.timings.chunkRangeCheckSmall.stopTiming();
                         if (smallRadiusOutsideRange) { // Spigot
                             // Paper end
@@ -709,7 +740,7 @@ public class ChunkProviderServer extends IChunkProvider {
                                 }
                                 // CraftBukkit end
 
-                                if (enumcreaturetype != EnumCreatureType.MISC && (!enumcreaturetype.c() || this.allowAnimals) && (enumcreaturetype.c() || this.allowMonsters) && (!enumcreaturetype.d() || flag2)) {
+                                if (enumcreaturetype != EnumCreatureType.MISC && (!enumcreaturetype.c() || this.allowAnimals) && (enumcreaturetype.c() || spawnMonsters) && (!enumcreaturetype.d() || flag2)) { // Paper - implement configurable spawn interval for monsters
                                     int k1 = limit * l / ChunkProviderServer.b; // CraftBukkit - use per-world limits
 
                                     // Paper start - only allow spawns upto the limit per chunk and update count afterwards
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index e23298e34..1e4d35bbf 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -111,6 +111,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         return this.viewDistance == -1? dfl : this.viewDistance;
     }
     // Paper end
+    double lastEntitySpawnRadiusSquared; // Paper - optimise isOutsideRange, this field is in blocks
 
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super((World) worldserver, gameprofile);
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index ff6f01e60..3937653a8 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -133,6 +133,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
     // Paper end
 
+    // Paper start - optimise isOutsideRange check for chunks
+    // A note about the naming used here:
+    // Previously, mojang used a "spawn range" of 8 for controlling both ticking and
+    // mob spawn range. However, spigot makes the spawn range configurable by
+    // checking if the chunk is in the tick range (8) and the spawn range
+    // obviously this means a spawn range > 8 cannot be implemented
+
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobSpawnMap; // this map is absent from updateMaps since it's controlled at the start of a tick
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerChunkTickRangeMap;
+
+    // these maps are named after spigot's uses
+    // Paper end
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         this.updateMaps(player);
 
@@ -148,6 +161,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.getChunkMapDistanceManager().playerTicketHandler.removePlayer(player);
         // Paper end
 
+        // Paper start - optimise isOutsideRange check for chunks
+        this.playerMobSpawnMap.remove(player);
+        this.playerChunkTickRangeMap.remove(player);
+        // Paper end
 
 
     }
@@ -165,6 +182,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveViewDistance + 1);
         // Paper end
 
+        // Paper start - optimise isOutsideRange check for chunks
+        this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, ChunkMapDistance.MOB_SPAWN_RANGE);
+        // Paper end
 
     }
 
@@ -227,6 +247,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 java.util.Arrays.fill(tempPacket, null);
             });
         // Paper end
+
+        // Paper start - optimise isOutsideRange check for chunks
+        this.playerChunkTickRangeMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+        this.playerMobSpawnMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+        // Paper end
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -246,6 +271,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return entityPlayer.mobCounts[enumCreatureType.ordinal()];
     }
 
+    private static double getDistanceSquaredFromChunk(ChunkCoordIntPair chunkPos, Entity entity) { return a(chunkPos, entity); } // Paper - OBFHELPER
     private static double a(ChunkCoordIntPair chunkcoordintpair, Entity entity) {
         double d0 = (double) (chunkcoordintpair.x * 16 + 8);
         double d1 = (double) (chunkcoordintpair.z * 16 + 8);
@@ -1337,18 +1363,42 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return isOutsideOfRange(chunkcoordintpair, false);
     }
 
-    boolean isOutsideOfRange(ChunkCoordIntPair chunkcoordintpair, boolean reducedRange) {
-        int chunkRange = world.spigotConfig.mobSpawnRange;
-        chunkRange = (chunkRange > world.spigotConfig.viewDistance) ? (byte) world.spigotConfig.viewDistance : chunkRange;
-        chunkRange = (chunkRange > 8) ? 8 : chunkRange;
+    // Paper start
+    final boolean isOutsideOfRange(ChunkCoordIntPair chunkcoordintpair, boolean reducedRange) {
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> playersInRange = (reducedRange ? this.playerMobSpawnMap : this.playerChunkTickRangeMap).getObjectsInRange(chunkcoordintpair);
 
-        double blockRange = (reducedRange) ? Math.pow(chunkRange << 4, 2) : 16384.0D;
-        // Spigot end
-        long i = chunkcoordintpair.pair();
+        Object[] backingSet = playersInRange.getBackingSet();
 
-        return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
-            return !entityplayer.isSpectator() && a(chunkcoordintpair, (Entity) entityplayer) < blockRange; // Spigot
-        });
+        if (reducedRange) {
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object raw = backingSet[i];
+                if (!(raw instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer) raw;
+                // don't check spectator and whatnot, already handled by mob spawn map update
+                if (player.lastEntitySpawnRadiusSquared > getDistanceSquaredFromChunk(chunkcoordintpair, player)) {
+                    return false; // in range
+                }
+            }
+        } else {
+            final double range = (ChunkMapDistance.MOB_SPAWN_RANGE * 16) * (ChunkMapDistance.MOB_SPAWN_RANGE * 16);
+            // before spigot, mob spawn range was actually mob spawn range + tick range, but it was split
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object raw = backingSet[i];
+                if (!(raw instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer) raw;
+                // don't check spectator and whatnot, already handled by mob spawn map update
+                if (range > getDistanceSquaredFromChunk(chunkcoordintpair, player)) {
+                    return false; // in range
+                }
+            }
+        }
+        // no players in range
+        return true;
+        // Paper end
     }
 
     private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } // Paper - OBFHELPER
-- 
2.24.0.windows.2

