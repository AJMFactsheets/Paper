From 58445ac24ffadccf636e1ecbdf09676e4fc58187 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Fri, 27 Dec 2019 19:09:23 -0800
Subject: [PATCH] Improve random tick performance

Massive performance improvement for random block ticking.
The performance increase comes from the fact that the vast
majority of attempted block ticks (~95% in my testing) fail
because the randomly selected block is not tickable.

Now only tickable blocks are targeted, however this means that
the maximum number of block ticks occurs per chunk. However,
not all chunks are going to be targeted. The percent chance
of a chunk being targeted is based on how many tickable blocks
are in the chunk.
This means that while block ticks are spread out less, the
total number of blocks ticked per world tick remains the same.

diff --git a/src/main/java/com/destroystokyo/paper/util/random/ThreadUnsafeRandom.java b/src/main/java/com/destroystokyo/paper/util/random/ThreadUnsafeRandom.java
new file mode 100644
index 00000000..a09beba7
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/random/ThreadUnsafeRandom.java
@@ -0,0 +1,29 @@
+package com.destroystokyo.paper.util.random;
+
+import java.util.Random;
+
+public final class ThreadUnsafeRandom extends Random {
+
+    // See javadoc and internal comments for java.util.Random where these values come from, how they are used, and the author & license for them.
+    private static final long multiplier = 0x5DEECE66DL;
+    private static final long addend = 0xBL;
+    private static final long mask = (1L << 48) - 1;
+
+    private static long initialScramble(long seed) {
+        return (seed ^ multiplier) & mask;
+    }
+
+    private long seed;
+
+    @Override
+    public void setSeed(long seed) {
+        // note: called by Random constructor
+        this.seed = initialScramble(seed);
+    }
+
+    @Override
+    protected int next(int bits) {
+        // avoid the expensive CAS logic used by superclass
+        return (int) (((this.seed = this.seed * multiplier + addend) & mask) >>> (48 - bits));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BiomeBase.java b/src/main/java/net/minecraft/server/BiomeBase.java
index 0102a170..fe182efa 100644
--- a/src/main/java/net/minecraft/server/BiomeBase.java
+++ b/src/main/java/net/minecraft/server/BiomeBase.java
@@ -47,6 +47,7 @@ public abstract class BiomeBase {
                 protected void rehash(int i) {}
             };
 
+            long2floatlinkedopenhashmap.defaultReturnValue(Float.NaN);
             long2floatlinkedopenhashmap.defaultReturnValue(Float.NaN);
             return long2floatlinkedopenhashmap;
         });
@@ -166,12 +167,20 @@ public abstract class BiomeBase {
     }
 
     public boolean a(IWorldReader iworldreader, BlockPosition blockposition, boolean flag) {
+        // Paper start - add chunk parameter
+        return this.transformWater(iworldreader, blockposition, flag, null);
+    }
+    public boolean transformWater(IWorldReader iworldreader, BlockPosition blockposition, boolean flag, IChunkAccess chunk) {
+        // Paper end
         if (this.getAdjustedTemperature(blockposition) >= 0.15F) {
             return false;
         } else {
             if (blockposition.getY() >= 0 && blockposition.getY() < 256 && iworldreader.getBrightness(EnumSkyBlock.BLOCK, blockposition) < 10) {
-                IBlockData iblockdata = iworldreader.getType(blockposition);
-                Fluid fluid = iworldreader.getFluid(blockposition);
+                // Paper start - use chunk parameter, avoid chunk lookup
+                if (chunk == null) chunk = iworldreader.getChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+                IBlockData iblockdata = chunk.getType(blockposition);
+                Fluid fluid = iblockdata.getFluid(); // getFluid is literally getType + getFluid, so avoid yet another chunk and block lookup
+                // Paper end
 
                 if (fluid.getType() == FluidTypes.WATER && iblockdata.getBlock() instanceof BlockFluids) {
                     if (!flag) {
@@ -191,11 +200,19 @@ public abstract class BiomeBase {
     }
 
     public boolean b(IWorldReader iworldreader, BlockPosition blockposition) {
+        // Paper start - add chunk parameter
+        return this.canPlaceSnow(iworldreader, blockposition, null);
+    }
+    public boolean canPlaceSnow(IWorldReader iworldreader, BlockPosition blockposition, IChunkAccess chunk) {
+        // Paper end
         if (this.getAdjustedTemperature(blockposition) >= 0.15F) {
             return false;
         } else {
             if (blockposition.getY() >= 0 && blockposition.getY() < 256 && iworldreader.getBrightness(EnumSkyBlock.BLOCK, blockposition) < 10) {
-                IBlockData iblockdata = iworldreader.getType(blockposition);
+                // Paper start - use chunk parameter to avoid chunk lookup
+                if (chunk == null) chunk = iworldreader.getChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+                IBlockData iblockdata = chunk.getType(blockposition);
+                // Paper end
 
                 if (iblockdata.isAir() && Blocks.SNOW.getBlockData().canPlace(iworldreader, blockposition)) {
                     return true;
diff --git a/src/main/java/net/minecraft/server/BlockFluids.java b/src/main/java/net/minecraft/server/BlockFluids.java
index 6d351f09..a44f65f4 100644
--- a/src/main/java/net/minecraft/server/BlockFluids.java
+++ b/src/main/java/net/minecraft/server/BlockFluids.java
@@ -27,7 +27,7 @@ public class BlockFluids extends Block implements IFluidSource {
 
     @Override
     public void b(IBlockData iblockdata, WorldServer worldserver, BlockPosition blockposition, Random random) {
-        worldserver.getFluid(blockposition).b(worldserver, blockposition, random);
+        iblockdata.getFluid().b(worldserver, blockposition, random); // Paper - avoid getType call
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 11eff5fe..9ca63760 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -90,6 +90,8 @@ public class Chunk implements IChunkAccess {
     private final int[] inventoryEntityCounts = new int[16];
     // Paper end
 
+    final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper - keep tickable block list per chunk
+
     public Chunk(World world, ChunkCoordIntPair chunkcoordintpair, BiomeStorage biomestorage, ChunkConverter chunkconverter, TickList<Block> ticklist, TickList<FluidType> ticklist1, long i, @Nullable ChunkSection[] achunksection, @Nullable Consumer<Chunk> consumer) {
         this.sections = new ChunkSection[16];
         this.e = Maps.newHashMap();
@@ -124,6 +126,18 @@ public class Chunk implements IChunkAccess {
         this.v = consumer;
         if (achunksection != null) {
             if (this.sections.length == achunksection.length) {
+                // Paper start
+                for (ChunkSection section : achunksection) {
+                    if (section != null) {
+                        section.chunk = this;
+                        int offset = com.destroystokyo.paper.util.maplist.IBlockDataList.getLocationKey(0, section.yPos, 0);
+                        for (it.unimi.dsi.fastutil.longs.LongIterator iterator = section.tickingList.getRawIterator(); iterator.hasNext();) {
+                            long raw = iterator.nextLong();
+                            this.tickingList.add(com.destroystokyo.paper.util.maplist.IBlockDataList.getLocationFromRaw(raw) + offset, com.destroystokyo.paper.util.maplist.IBlockDataList.getBlockDataFromRaw(raw));
+                        }
+                    }
+                }
+                // Paper end
                 System.arraycopy(achunksection, 0, this.sections, 0, this.sections.length);
             } else {
                 Chunk.LOGGER.warn("Could not set level chunk sections, array length is {} instead of {}", achunksection.length, this.sections.length);
@@ -134,6 +148,10 @@ public class Chunk implements IChunkAccess {
         this.bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
     }
 
+    public final int getHighestBlockYAt(HeightMap.Type type, int x, int z) {
+        return this.heightMap.get(type).a(x, z); // TODO obfhelper
+    }
+
     public org.bukkit.Chunk bukkitChunk;
     public org.bukkit.Chunk getBukkitChunk() {
         return bukkitChunk;
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 4526527a..4ff53367 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -5,11 +5,13 @@ import javax.annotation.Nullable;
 public class ChunkSection {
 
     public static final DataPalette<IBlockData> GLOBAL_PALETTE = new DataPaletteGlobal<>(Block.REGISTRY_ID, Blocks.AIR.getBlockData());
-    private final int yPos;
+    final int yPos; // Paper - private -> package
     short nonEmptyBlockCount; // Paper - private -> package-private
-    private short tickingBlockCount;
+    short tickingBlockCount; // Paper - private -> package
     private short e;
     final DataPaletteBlock<IBlockData> blockIds;
+    Chunk chunk; // Paper
+    final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
 
     public ChunkSection(int i) {
         // Paper start - add parameters
@@ -31,6 +33,11 @@ public class ChunkSection {
         this.tickingBlockCount = short1;
         this.e = short2;
         this.blockIds = new DataPaletteBlock<>(ChunkSection.GLOBAL_PALETTE, Block.REGISTRY_ID, GameProfileSerializer::d, GameProfileSerializer::a, Blocks.AIR.getBlockData(), world instanceof GeneratorAccess ? ((GeneratorAccess) world).getMinecraftWorld().chunkPacketBlockController.getPredefinedBlockData(world, chunk, this, initializeBlocks) : null, initializeBlocks); // Paper - Anti-Xray - Add predefined block data
+        // Paper start
+        if (chunk instanceof Chunk) {
+            this.chunk = (Chunk)chunk;
+        }
+        // Paper end
     }
 
     public IBlockData getType(int i, int j, int k) {
@@ -69,6 +76,12 @@ public class ChunkSection {
             --this.nonEmptyBlockCount;
             if (iblockdata1.q()) {
                 --this.tickingBlockCount;
+                // Paper start
+                this.tickingList.remove(i, j, k);
+                if (this.chunk != null) {
+                    this.chunk.tickingList.remove(i, j + this.yPos, k);
+                }
+                // Paper end
             }
         }
 
@@ -80,6 +93,12 @@ public class ChunkSection {
             ++this.nonEmptyBlockCount;
             if (iblockdata.q()) {
                 ++this.tickingBlockCount;
+                // Paper start
+                this.tickingList.add(i, j, k, iblockdata);
+                if (this.chunk != null) {
+                    this.chunk.tickingList.add(i, j + this.yPos, k, iblockdata);
+                }
+                // Paper end
             }
         }
 
@@ -115,23 +134,40 @@ public class ChunkSection {
     }
 
     public void recalcBlockCounts() {
+        // Paper start
+        int offset = com.destroystokyo.paper.util.maplist.IBlockDataList.getLocationKey(0, this.yPos, 0);
+        if (this.chunk != null) {
+            for (it.unimi.dsi.fastutil.longs.LongIterator iterator = this.tickingList.getRawIterator(); iterator.hasNext();) {
+                long raw = iterator.nextLong();
+                this.chunk.tickingList.remove(com.destroystokyo.paper.util.maplist.IBlockDataList.getLocationFromRaw(raw) + offset);
+            }
+        }
+        this.tickingList.clear();
+        // Paper end
         this.nonEmptyBlockCount = 0;
         this.tickingBlockCount = 0;
         this.e = 0;
-        this.blockIds.a((iblockdata, i) -> {
+        this.blockIds.forEachLocation((iblockdata, location) -> { // Paper
             Fluid fluid = iblockdata.getFluid();
 
             if (!iblockdata.isAir()) {
-                this.nonEmptyBlockCount = (short) (this.nonEmptyBlockCount + i);
+                this.nonEmptyBlockCount = (short) (this.nonEmptyBlockCount + 1); // Paper
                 if (iblockdata.q()) {
-                    this.tickingBlockCount = (short) (this.tickingBlockCount + i);
+                    this.tickingBlockCount = (short) (this.tickingBlockCount + 1); // Paper
+                    // Paper start
+                    this.tickingList.add(location, iblockdata);
+                    if (this.chunk != null) {
+                        this.chunk.tickingList.add(location + offset, iblockdata);
+                    }
+                    this.tickingBlockCount = (short) (this.tickingBlockCount + 1);
+                    // Paper end
                 }
             }
 
             if (!fluid.isEmpty()) {
-                this.nonEmptyBlockCount = (short) (this.nonEmptyBlockCount + i);
+                this.nonEmptyBlockCount = (short) (this.nonEmptyBlockCount + 1); // Paper
                 if (fluid.h()) {
-                    this.e = (short) (this.e + i);
+                    this.e = (short) (this.e + 1); // Paper
                 }
             }
 
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
index f9680b68..8dd23e08 100644
--- a/src/main/java/net/minecraft/server/DataBits.java
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -127,4 +127,47 @@ public class DataBits {
 
         }
     }
+
+    // Paper start
+    public void forEach(DataBitConsumer consumer) {
+        // TODO check on update
+        // Note: copied from above
+        int i = this.a.length;
+
+        if (i != 0) {
+            int j = 0;
+            long k = this.a[0];
+            long l = i > 1 ? this.a[1] : 0L;
+
+            for (int i1 = 0; i1 < this.d; ++i1) {
+                int j1 = i1 * this.b;
+                int k1 = j1 >> 6;
+                int l1 = (i1 + 1) * this.b - 1 >> 6;
+                int i2 = j1 ^ k1 << 6;
+
+                if (k1 != j) {
+                    k = l;
+                    l = k1 + 1 < i ? this.a[k1 + 1] : 0L;
+                    j = k1;
+                }
+
+                if (k1 == l1) {
+                    consumer.accept(i1, (int) (k >>> i2 & this.c)); // our only diff
+                } else {
+                    int j2 = 64 - i2;
+
+                    consumer.accept(i1, (int) ((k >>> i2 | l << j2) & this.c)); // our only diff
+                }
+            }
+
+        }
+    }
+
+    @FunctionalInterface
+    static interface DataBitConsumer {
+
+        void accept(int location, int data);
+
+    }
+    // Paper end
 }
diff --git a/src/main/java/net/minecraft/server/DataPaletteBlock.java b/src/main/java/net/minecraft/server/DataPaletteBlock.java
index 44aed672..fa664897 100644
--- a/src/main/java/net/minecraft/server/DataPaletteBlock.java
+++ b/src/main/java/net/minecraft/server/DataPaletteBlock.java
@@ -287,6 +287,14 @@ public class DataPaletteBlock<T> implements DataPaletteExpandable<T> {
         });
     }
 
+    // Paper start
+    public void forEachLocation(DataPaletteBlock.a<T> datapaletteblock_a) {
+        this.getDataBits().forEach((int location, int data) -> {
+            datapaletteblock_a.accept(this.getDataPalette().getObject(data), location);
+        });
+    }
+    // Paper end
+
     @FunctionalInterface
     public interface a<T> {
 
diff --git a/src/main/java/net/minecraft/server/Fluid.java b/src/main/java/net/minecraft/server/Fluid.java
index 7c9ba128..22e085b6 100644
--- a/src/main/java/net/minecraft/server/Fluid.java
+++ b/src/main/java/net/minecraft/server/Fluid.java
@@ -39,6 +39,7 @@ public interface Fluid extends IBlockDataHolder<Fluid> {
         this.getType().a(world, blockposition, this);
     }
 
+    default boolean isLava() { return this.h(); } // Paper - OBFHELPER, also check subclass override (FluidImpl)
     default boolean h() {
         return this.getType().j();
     }
diff --git a/src/main/java/net/minecraft/server/FluidImpl.java b/src/main/java/net/minecraft/server/FluidImpl.java
index ac9b8909..fe421c2c 100644
--- a/src/main/java/net/minecraft/server/FluidImpl.java
+++ b/src/main/java/net/minecraft/server/FluidImpl.java
@@ -6,10 +6,20 @@ public class FluidImpl extends BlockDataAbstract<FluidType, Fluid> implements Fl
 
     public FluidImpl(FluidType fluidtype, ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap) {
         super(fluidtype, immutablemap);
+        this.isLava = this.getType().j(); // Paper
     }
 
     @Override
     public FluidType getType() {
         return (FluidType) this.a;
     }
+
+    // Paper start
+    private final boolean isLava;
+
+    @Override
+    public final boolean h() { // obfhelper is in superclass
+        return this.isLava;
+    }
+    // Paper end
 }
diff --git a/src/main/java/net/minecraft/server/IBlockData.java b/src/main/java/net/minecraft/server/IBlockData.java
index de438816..ec265315 100644
--- a/src/main/java/net/minecraft/server/IBlockData.java
+++ b/src/main/java/net/minecraft/server/IBlockData.java
@@ -27,6 +27,7 @@ public class IBlockData extends BlockDataAbstract<Block, IBlockData> implements
         super(block, immutablemap);
         this.d = block.a(this);
         this.e = block.o(this);
+        this.isTicking = this.getBlock().isTicking(this); // Paper - cache isTicking
     }
 
     public void c() {
@@ -267,12 +268,22 @@ public class IBlockData extends BlockDataAbstract<Block, IBlockData> implements
         return this.getBlock().a(tag);
     }
 
+    private Fluid fluid; // Paper - cache this
     public Fluid getFluid() {
-        return this.getBlock().a_(this);
+        // Paper start - cache fluid type
+        // init issues prevent us from making the field final
+        if (this.fluid != null) {
+            return this.fluid;
+        }
+        return this.fluid = this.getBlock().a_(this);
+        // Paper end
     }
 
+    // Paper start - cache isTicking
+    private final boolean isTicking;
     public boolean q() {
-        return this.getBlock().isTicking(this);
+        return this.isTicking;
+        // Paper end
     }
 
     public final SoundEffectType getStepSound() { return this.r(); } // Paper - OBFHELPER
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 0ada91d7..e11f28a3 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -551,6 +551,7 @@ public class WorldServer extends World {
     }
 
     private final BlockPosition.MutableBlockPosition chunkTickMutablePosition = new BlockPosition.MutableBlockPosition(); // Paper - use mutable blockpos to reduce allocation rate of blockpos
+    private final com.destroystokyo.paper.util.random.ThreadUnsafeRandom randomTickRandom = new com.destroystokyo.paper.util.random.ThreadUnsafeRandom(); // Paper
 
     public void a(Chunk chunk, int i) {
         ChunkCoordIntPair chunkcoordintpair = chunk.getPos();
@@ -562,7 +563,7 @@ public class WorldServer extends World {
         gameprofilerfiller.enter("thunder");
         final BlockPosition.MutableBlockPosition blockposition = this.chunkTickMutablePosition; // Paper - use mutable to reduce allocation rate, final to force compile fail on change
 
-        if (!this.paperConfig.disableThunder && flag && this.U() && this.random.nextInt(100000) == 0) { // Paper - Disable thunder
+        if (!this.paperConfig.disableThunder && flag && this.U() && this.randomTickRandom.nextInt(100000) == 0) { // Paper - Disable thunder // Paper
             blockposition.setValues(this.a(this.getRandomBlockPosition(j, 0, k, 15, blockposition))); // Paper - use mutable blockpos to reduce allocation rate
             if (this.isRainingAt(blockposition)) {
                 DifficultyDamageScaler difficultydamagescaler = this.getDamageScaler(blockposition);
@@ -582,61 +583,75 @@ public class WorldServer extends World {
         }
 
         gameprofilerfiller.exitEnter("iceandsnow");
-        if (!this.paperConfig.disableIceAndSnow && this.random.nextInt(16) == 0) { // Paper - Disable ice and snow
-            blockposition.setValues(this.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, this.getRandomBlockPosition(j, 0, k, 15, blockposition))); // Paper - use mutable blockpos to reduce allocation rate
-            BlockPosition blockposition1 = blockposition.down();
+        // Paper start - optimise chunk ticking
+        if (!this.paperConfig.disableIceAndSnow && this.randomTickRandom.nextInt(16) == 0) { // Paper - Disable ice and snow
+            this.getRandomBlockPosition(j, 0, k, 15, blockposition);
+            int normalY = chunk.getHighestBlockYAt(HeightMap.Type.MOTION_BLOCKING, blockposition.getX(), blockposition.getZ());
+            int downY = normalY - 1;
+            blockposition.setY(normalY);
             BiomeBase biomebase = this.getBiome(blockposition);
 
-            if (biomebase.a((IWorldReader) this, blockposition1)) {
-                org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(this, blockposition1, Blocks.ICE.getBlockData(), null); // CraftBukkit
+            blockposition.setY(downY);
+            if (biomebase.transformWater((IWorldReader) this, blockposition, true, chunk)) {
+                org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(this, blockposition, Blocks.ICE.getBlockData(), null); // CraftBukkit
             }
 
-            if (flag && biomebase.b(this, blockposition)) {
+            blockposition.setY(normalY);
+            if (flag && biomebase.canPlaceSnow(this, blockposition, chunk)) {
                 org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(this, blockposition, Blocks.SNOW.getBlockData(), null); // CraftBukkit
             }
+            blockposition.setY(downY);
 
-            if (flag && this.getBiome(blockposition1).d() == BiomeBase.Precipitation.RAIN) {
-                this.getType(blockposition1).getBlock().c((World) this, blockposition1);
+            if (flag && this.getBiome(blockposition).d() == BiomeBase.Precipitation.RAIN) {
+                chunk.getType(blockposition).getBlock().c((World) this, blockposition);
             }
         }
+        // Paper end
 
-        gameprofilerfiller.exitEnter("tickBlocks");
-        timings.chunkTicksBlocks.startTiming(); // Paper
-        if (i > 0) {
-            ChunkSection[] achunksection = chunk.getSections();
-            int l = achunksection.length;
-
-            for (int i1 = 0; i1 < l; ++i1) {
-                ChunkSection chunksection = achunksection[i1];
-
-                if (chunksection != Chunk.a && chunksection.d()) {
-                    int j1 = chunksection.getYPosition();
-
-                    for (int k1 = 0; k1 < i; ++k1) {
-                        BlockPosition blockposition2 = this.getRandomBlockPosition(j, j1, k, 15, blockposition); // Paper - use mutable to reduce allocation rate
-
-                        gameprofilerfiller.enter("randomTick");
-                        IBlockData iblockdata = chunksection.getType(blockposition2.getX() - j, blockposition2.getY() - j1, blockposition2.getZ() - k);
+        gameprofilerfiller.exit();
+        // Paper start - optimise random block tick
+        int blocks = chunk.tickingList.size();
+        if (i > 0 && blocks > 0) { /* Concrete */
+            if ((this.randomTickRandom.nextInt() & (16 * 16 * 256 - 1)) > blocks) {
+                // we optimise random block ticking by realising that most of the blocks we will try to tick
+                // are not tickable. Instead we only tick tickable blocks, but only if the above
+                // statement is true
+                // Note: The number of blocks that get ticked per tick still REMAIN the same.
+                return;
+            }
+            gameprofilerfiller.enter("tickBlocks");
+            timings.chunkTicksBlocks.startTiming(); // Paper
 
-                        if (iblockdata.q()) {
-                            iblockdata.getBlock().randomTick = true; // Paper - fix MC-113809
-                            iblockdata.b(this, blockposition2, this.random);
-                            iblockdata.getBlock().randomTick = false; // Paper - fix MC-113809
-                        }
+            int toTick = i << 4; // i * 16
 
-                        Fluid fluid = iblockdata.getFluid();
+            gameprofilerfiller.enter("randomTick");
+            for (int tick = 0; tick < toTick; ++tick) {
+                char tickingSize = (char)chunk.tickingList.size();
+                if (tickingSize == 0) {
+                    break;
+                }
+                int index = ((char)this.randomTickRandom.nextInt()) % tickingSize;
+                long raw = chunk.tickingList.getRaw(index);
+                int location = com.destroystokyo.paper.util.maplist.IBlockDataList.getLocationFromRaw(raw);
+                int randomX = location & 15;
+                int randomY = (location >>> (4 + 4)) & 255;
+                int randomZ = (location >>> 4) & 15;
+                BlockPosition blockposition2 = blockposition.setValues(j + randomX, randomY, k + randomZ);
+                IBlockData iblockdata = com.destroystokyo.paper.util.maplist.IBlockDataList.getBlockDataFromRaw(raw);
 
-                        if (fluid.h()) {
-                            fluid.b(this, blockposition2, this.random);
-                        }
+                iblockdata.getBlock().randomTick = true; // Paper - fix MC-113809
+                iblockdata.b(this, blockposition2, this.randomTickRandom);
+                iblockdata.getBlock().randomTick = false; // Paper - fix MC-113809
 
-                        gameprofilerfiller.exit();
-                    }
-                }
+                // We drop the fluid tick since LAVA is ALREADY TICKED by the above method.
+                // TODO THIS NEEDS TO BE CHECKED ON UPDATE
             }
+
+            gameprofilerfiller.exit();
+            timings.chunkTicksBlocks.stopTiming(); // Paper
+            gameprofilerfiller.exit();
+            // Paper end
         }
-        timings.chunkTicksBlocks.stopTiming(); // Paper
-        gameprofilerfiller.exit();
     }
 
     protected BlockPosition a(BlockPosition blockposition) {
-- 
2.24.0.windows.2

